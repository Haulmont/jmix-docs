= Entities API

The Entities API provides different capabilities to interact with entity instances. This API mainly consists of CRUD operations that can be performed on the entities. The ability to load entity data is extended by different ways of filtering and JPQL.

NOTE: When performing operations on entities through this generic API, the regular Jmix security permissions are applied from the user obtained the authentication token.


== Load Entities

The Entities API allows you to load entities through the API in various ways:

* <<Load Entity by ID,Load Entity by ID>> loads a single entity by its unique identifier (ID).

* <<Load List of Entities,Load List of Entities>> loads all entities with pagination and sorting.

* <<Load Entities via Search Filter,Load Entities via Search Filter>> allows you to filter for entities by filter criteria in the Request.

* <<Load Entities via JPQL,Load Entities via JPQL>> loads entities via pre-configuring named JPQL queries.


=== Load Entity by ID

The first way of loading an entity via the Entities API is by loading it via its ID. The corresponding endpoint for this is the Load Entity endpoint `entities/:entityName/:entityId`.

The `:entityName` path parameter defines which entity type it is. The value is defined in the entity definition:

[source,java]
.Order.java
----

@JmixEntity
@Table(name = "RSTEX11_ORDER")
@Entity(name = "rstex11_Order") //<1>
public class Order {
    // ...
}
----
<1> The name attribute value `rstex11_Order` of the `@Entity` JPA annotation indicates the `entityName` parameter in the Entities API.

The Load Entity endpoint returns a single instance in case it is found by its identifier. Otherwise, HTTP status code `404 - Not found` is returned.

In the example below the Order with the ID `21021f78-edac-224b-e6f8-6e71e02a0f0d` is loaded. Furthermore, in this example the optional URL query parameter `fetchPlan` is used to define which attributes to return as part of the response.

[source, http request]
.Request
----
GET http://localhost:8080/rest
            /entities
            /rstex11_Order
            /21021f78-edac-224b-e6f8-6e71e02a0f0d
            ?fetchPlan=order-with-details
----

[source, json]
.Response: 200 - OK
----
{
  "_entityName": "rstex11_Order", //<1>
  "_instanceName": "rest.sample.entity.Order-21021f78-edac-224b-e6f8-6e71e02a0f0d [detached]",
  "id": "21021f78-edac-224b-e6f8-6e71e02a0f0d",
  "date": "2020-12-13", //<2>
  "amount": 49.99,
  "createdDate": "2021-02-06T12:03:38.049",
  "createdBy": "admin",
  "lastModifiedDate": "2021-02-06T12:03:38.049",
  "lines": [ //<3>
    {
      "_entityName": "rstex11_OrderLine",
      "_instanceName": "rest.sample.entity.OrderLine-64e4fbb0-7fd6-818b-984e-a8769c4fbe88 [detached]",
      "id": "64e4fbb0-7fd6-818b-984e-a8769c4fbe88",
      "product": {
        "_entityName": "rstex11_Product",
        "_instanceName": "Outback Power Remote Power System",
        "id": "7750adbe-6c30-cede-31a6-577a1a96aa83",
        "name": "Outback Power Remote Power System"
      },
      "quantity": 1.0,
      "createdDate": "2021-02-06T12:03:38.049",
      "createdBy": "admin",
      "lastModifiedDate": "2021-02-06T12:03:38.049",
      "version": 1
    }
  ],
  "version": 1,
  "customer": {
    "_entityName": "rstex11_Customer",
    "_instanceName": "Sidney Chandler",
    "id": "0826806e-6074-90fa-f241-564b5c94d018",
    "createdDate": "2021-02-06T12:00:53.72",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:00:53.72",
    "name": "Sidney Chandler",
    "version": 1
  }
}
----
<1> Some metadata about the entity instance is returned as JSON keys (`entityName`, `_instanceName` and `id`).
<2> The JSON contains each business attribute as a JSON key.
<3> The fetch plan `order-with-details` ensures that additional attributes like `lines` and `customer` are also included.

=== Load List of Entities

You can load a list of entities of any type using the Load Entity List API endpoint: `/entities/:entityName`. This API includes pagination, sorting and fetch plans.

[source, http request]
.Request
----
GET http://localhost:8080/rest/entities/rstex11_Customer
----

[source, json]
.Response: HTTP 200 - OK
----
[
  {
    "_entityName": "rstex11_Customer",
    "_instanceName": "Sidney Chandler",
    "id": "0826806e-6074-90fa-f241-564b5c94d018",
    "createdDate": "2021-02-06T12:00:53.72",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:00:53.72",
    "name": "Sidney Chandler",
    "version": 1
  },
  {
    "_entityName": "rstex11_Customer",
    "_instanceName": "Randall Bishop",
    "id": "22efc597-69a9-aeef-4e4a-7afccd8e5767",
    "createdDate": "2021-03-01T08:19:08.871",
    "createdBy": "admin",
    "lastModifiedDate": "2021-03-01T08:19:08.871",
    "name": "Randall Bishop",
    "version": 1
  },
  {
    "_entityName": "rstex11_Customer",
    "_instanceName": "Shelby Robinson",
    "id": "bd1c8e90-3d35-cbe2-9efd-167202c758d2",
    "createdDate": "2021-02-06T12:02:05.328",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:02:05.328",
    "name": "Shelby Robinson",
    "version": 1
  }
]
----

It is also possible to further control the behavior of the API by using the following URL query parameters:

fetchPlan:: name of an entity's xref:data-access:fetch-plans.adoc[fetch plan] `(String)`.
limit:: the number of entities to be returned by the API `(int)`.
offset:: the position of the first returned entity `(int)`.
sort:: an entity attribute that will be used for sorting `(String)`.
+
* `+attribute` or simply `attribute` for ascending order
* `-attribute` for descending order.

The following example demonstrates how to load the third "page" of 5 `Order` entities (the 10 - 15 entity) sorted by the date attribute and containing all attributes of the `order-with-details` fetch plan.

[source, http request]
.Request
----
GET http://localhost:8080/rest
            /entities
            /rstex11_Order
            ?fetchPlan=order-with-details
            &limit=5
            &offset=10
            &sort=+date
----

[source, json]
.Response: HTTP 200 - OK
----
[
  {
    "_entityName": "rstex11_Order",
    "_instanceName": "rest.sample.entity.Order-21021f78-edac-224b-e6f8-6e71e02a0f0d [detached]",
    "id": "21021f78-edac-224b-e6f8-6e71e02a0f0d",
    "date": "2020-12-13",
    "amount": 49.99,
    "createdDate": "2021-02-06T12:03:38.049",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:03:38.049",
    "lines": [
      {
        "_entityName": "rstex11_OrderLine",
        "_instanceName": "rest.sample.entity.OrderLine-64e4fbb0-7fd6-818b-984e-a8769c4fbe88 [detached]",
        "id": "64e4fbb0-7fd6-818b-984e-a8769c4fbe88",
        "product": {
          "_entityName": "rstex11_Product",
          "_instanceName": "Outback Power Remote Power System",
          "id": "7750adbe-6c30-cede-31a6-577a1a96aa83",
          "name": "Outback Power Remote Power System"
        },
        "quantity": 1.0,
        "createdDate": "2021-02-06T12:03:38.049",
        "createdBy": "admin",
        "lastModifiedDate": "2021-02-06T12:03:38.049",
        "version": 1
      }
    ],
    "version": 1,
    "customer": {
      "_entityName": "rstex11_Customer",
      "_instanceName": "Sidney Chandler",
      "id": "0826806e-6074-90fa-f241-564b5c94d018",
      "createdDate": "2021-02-06T12:00:53.72",
      "createdBy": "admin",
      "lastModifiedDate": "2021-02-06T12:00:53.72",
      "name": "Sidney Chandler",
      "version": 1
    }
  },
  {
    "_entityName": "rstex11_Order",
    "_instanceName": "rest.sample.entity.Order-41aae331-b46b-85ee-b0bc-2de8cbf1ab86 [detached]",
    "id": "41aae331-b46b-85ee-b0bc-2de8cbf1ab86",
    "date": "2021-02-02",
    "amount": 283.55,
    "createdDate": "2021-02-06T12:04:37.372",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:04:37.372",
    "lines": [
      {
        "_entityName": "rstex11_OrderLine",
        "_instanceName": "rest.sample.entity.OrderLine-d89df652-9d06-8d3e-2f26-5387e96e5b5d [detached]",
        "id": "d89df652-9d06-8d3e-2f26-5387e96e5b5d",
        "product": {
          "_entityName": "rstex11_Product",
          "_instanceName": "Cotek Battery Charger",
          "id": "1ed85c7a-89f1-c339-a738-16307ed6003a",
          "name": "Cotek Battery Charger"
        },
        "quantity": 1.0,
        "createdDate": "2021-02-06T12:04:37.372",
        "createdBy": "admin",
        "lastModifiedDate": "2021-02-06T12:04:37.372",
        "version": 1
      },
      {
        "_entityName": "rstex11_OrderLine",
        "_instanceName": "rest.sample.entity.OrderLine-7ccd45ec-8878-2a4a-2c24-b5ac053b6d4c [detached]",
        "id": "7ccd45ec-8878-2a4a-2c24-b5ac053b6d4c",
        "product": {
          "_entityName": "rstex11_Product",
          "_instanceName": "Solar-One HUP Flooded Battery 48V",
          "id": "1860904a-5444-9c3e-9dc1-1d7a26d9ac19",
          "name": "Solar-One HUP Flooded Battery 48V"
        },
        "quantity": 1.0,
        "createdDate": "2021-02-06T12:04:37.372",
        "createdBy": "admin",
        "lastModifiedDate": "2021-02-06T12:04:37.372",
        "version": 1
      }
    ],
    "version": 1,
    "customer": {
      "_entityName": "rstex11_Customer",
      "_instanceName": "Shelby Robinson",
      "id": "bd1c8e90-3d35-cbe2-9efd-167202c758d2",
      "name": "Shelby Robinson",
      "version": 1
    }
  }
]
----

NOTE: Every entity in the response has a `_entityName` attribute with the name of the entity, and an `_instanceName` attribute with the xref:data-model:entities.adoc#instance-name[Instance Name] of the entity.

=== Load Entities via Search Filter

You can specify filter criteria when loading entities using the Entity Search Endpoint: `/entities/:entityName/search`.

Both HTTP methods `GET` and `POST` are possible when interacting with the search endpoint. In both cases the filter criterion has to be provided as part of the request.

The filter definition is a JSON structure that contains a set of conditions. A condition consists of the following attributes:

property:: the entity attribute that is being filtered on (like `amount` on the Order entity).
+
In case the attribute is a reference to another entity, it can also be a property path like `customer.name`

operator:: the filter operator. The following values are possible (depending on the property type):
+
`=`, `>`, `>=`, `<`, `&lt;=`, `<>`, `startsWith`, `endsWith`, `contains`, `doesNotContain`, `in`, `notIn`, `notEmpty`, `isNull`

value:: the value to search for. Value is not required for the `notEmpty` and `isNull` operators.

Additionally, conditions can be combined via `AND`, `OR` group conditions in order to define more complex filter criterion. The JSON structure of the filter definitions looks like this:

[source,json]
.Filter Criterion JSON structure
----
{
  "conditions": [
    {
      "group": "OR",
      "conditions": [
        {
          "property": "stringField",
          "operator": "=",
          "value": "stringValue"
        },
        {
          "property": "intField",
          "operator": ">",
          "value": 100
        }
      ]
    },
    {
      "property": "booleanField",
      "operator": "=",
      "value": true
    }
  ]
}
----

This is a representation of the Filter criterion: `\((stringField = stringValue) OR (intField > 100) AND (booleanField = true))`.

When using the HTTP POST method, the filter is part of the request body.

[source,http request]
.Filter POST Request
----
POST http://localhost:8080/rest/entities/rstex11_Order/search

{
  "filter": {
    "conditions": [
      {
        "property": "customer.name",
        "operator": "=",
        "value": "Shelby Robinson"
      }
    ]
  }
}
----

When using the `GET` method, the JSON filter criterion needs to be transferred via the URL Query parameter `filter`.

[source, http request]
.Filter GET Request
----
GET http://localhost:8080/rest
            /entities
            /rstex11_Order
            /search
            ?filter={"conditions":[{"property":"customer.name","operator":"contains","value":"Shelby"}]}
----

[IMPORTANT]
.URI Encoding
====
The HTTP URI standard only allows ASCII characters as part of the URI / URL. When using URL Query parameters for the filter definition, the JSON definition has to be URL encoded in order to match this requirement. This is also true for the `value` data that normally contains user input.

As there is also a practical limit of the URI length that can cause problems for big filter definitions, the `POST` method for filtering entities should be preferred as those restrictions do not apply.
====

=== Load Entities via JPQL

Another alternative to load entities from the application is to use predefined JPQL queries. The Entity Query Endpoint `/queries/:entityName/:queryName` is responsible for providing this capability. Queries can contain a list of parameters, that needs to be provided by the client. Additionally, the endpoint contains the same general parameters for pagination, fetch plans etc.


[TIP]
.When to use JPQL vs. Search Filter?
====
Jmix provides various ways to load entity data in a generic way. Use pre-defined JPQL queries when the search filter is not advanced enough to express the filter criterion. Also in case the parameter should be pre-defined and not be adjustable by the API client.
====

==== JPQL Query Configuration

In order to use the Entity Query endpoint you need to define the accessible queries. This happens via an XML configuration file, normally called `rest-queries.xml`. You need to create this new file in your Jmix application under `src/main/resources`. It lists all published queries with information about its parameters.

[source,xml]
.rest-queries.xml
----
<?xml version="1.0"?>
<queries xmlns="http://jmix.io/schema/rest/queries">
    <query name="ordersByDate" entity="rstex11_Order" fetchPlan="order-with-details">
        <jpql><![CDATA[select e from rstex11_Order e where e.date = :orderDate]]></jpql>
        <params>
            <param name="orderDate" type="java.time.LocalDate"/>
        </params>
    </query>
    <query name="ordersByCustomerName" entity="rstex11_Order" fetchPlan="order-with-details">
        <jpql><![CDATA[select e from rstex11_Order e where e.customer.name = :customerName]]></jpql>
        <params>
            <param name="customerName" type="java.lang.String"/>
        </params>
    </query>
</queries>
----

A query needs to have a unique `name` value as well as an `entity` reference. The combination of `name` and `entity` needs to be unique. Also, a `fetchPlan` needs to be referenced to indicate which entity attributes are returned.

In the `<jpql>` tag the actual query is configured. The parameters need to be listed within the `params` tag defining their name and Java type. In the query parameters you can reference via their name prefixed with a colon like `:customerName`.

After the file has been created and the queries have been defined, you need to register the `rest-queries.xml` configuration in the `application.properties` of your Jmix application:

[source,properties]
.application.properties
----
jmix.rest.queriesConfig = rest/sample/rest-queries.xml
----

You can invoke the Entity Query endpoint either by the `GET` or `POST` HTTP method. In case of the `GET`, the parameters are appended as URL query parameters.

[source, http request]
.Query API GET Request
----
GET http://localhost:8080/rest
        /queries
        /rstex11_Order
        /ordersByDate
        ?orderDate=2020-02-02
----


[IMPORTANT]
.URI Encoding
====
The URL should only contain ASCII characters. This means the values of the parameters need to be URL encoded, as those values normally represent direct user input and therefore it cannot be ensured that non-ascii characters are used.
====

In the case of using `POST`, the query parameters are transferred in the JSON body containing each parameter as a key.

[source, http request]
.Query API POST Request
----
POST http://localhost:8080/rest/queries/rstex11_Order/ordersByCustomerName

{
  "customerName": "Shelby Robinson"
}
----

==== Collection Parameters

It is also possible to define a parameter as a collection type. In this case the query definition should contain a `[]` indicator after the Java type.

[source,xml]
.rest-queries.xml
----
<?xml version="1.0"?>
<queries xmlns="http://jmix.io/schema/rest/queries">
    <query name="ordersByIds" entity="rstex11_Order" fetchPlan="order-with-details">
        <jpql><![CDATA[select e from rstex11_Order e where e.id in :ids]]></jpql>
        <params>
            <param name="ids" type="java.util.UUID[]"/> // <1>
        </params>
    </query>
</queries>
----
<1> The `ids` parameter is marked as collection of `UUID` type.

When this parameter is used in a query, the corresponding  IDs have to be provided as a JSON array.

[source, http request]
.Query API Collection Parameters Request
----
POST http://localhost:8080/rest/queries/rstex11_Order/ordersByIds

{
  "ids": [
    "41aae331-b46b-85ee-b0bc-2de8cbf1ab86",
    "21021f78-edac-224b-e6f8-6e71e02a0f0d"
  ]
}
----

== Create Entities

The Entities API lets you create entities by performing a `POST` request against the `/entities/:entityName` endpoint.

The request body contains a JSON object with the attributes of the entity.

NOTE: Attributes from xref:data-model:entities.adoc#traits[entity traits] like `id` or `createdBy` should not be part of the request. Those attributes are automatically added by Jmix while storing the entity.

When the entity is created successfully, the HTTP response status code `201 - Created` is returned. By default, a JSON metadata representation of the entity is returned mainly containing the newly created `id` attribute for further reference.

[source, http request]
.Request
----
POST http://localhost:8080/rest/entities/rstex11_Customer

{
  name: "Randall Bishop"
}
----


[source, json]
.Response: 201 - Created
----
{
  "_entityName": "rstex11_Customer",
  "_instanceName": "Randall Bishop",
  "id": "78e7996d-8b69-6526-8e9f-16262a1c4113"
}
----

Alternatively it is possible to define which attributes should be returned once the entity is created. This can be achieved through the URL query parameter `responseFetchPlan`. E.g. `/entities/rstex11_Order?responseFetchPlan=order-with-details` would return the complete order with all its details containing order lines, customer references etc.

TIP: The HTTP response Header `Location` indicates also the URL to the newly created entity instance for further operations (like fetching, updating or deleting).

=== Entity Validation

When an entity is created or updated, the regular entity validation is active and enforced by default. This means that invalid input (according to the entity validation annotations) from the API is rejected with the HTTP response status code `400 - Bad Request`.

The API returns detailed error messages for each validation violation in the following form of a JSON array. Each entry follows the structure:

message:: the (translated) human-readable error message of the violation
messageTemplate:: the non-interpolated error message for this constraint violation
path:: the attribute name (or property path) of the attribute that caused the violation
invalidValue:: the value that was part of the request for the attribute, which causes the violation


The following request contains two errors in the request, as 1. the `customer` attribute is required and 2. the `date` should not be in the future.

[source, http request]
.Invalid Request
----
POST http://localhost:8080/rest/entities/rstex11_Order

{
  "date": "2048-01-01",
  "amount": 49.99,
  "customer": null
}
----

The API then returns the list of violations of the entity validations.

[source, json]
.Response: 400 - Bad Request
----
[
  {
    "message": "javax.validation.constraints.PastOrPresent.message",
    "messageTemplate": "{javax.validation.constraints.PastOrPresent.message}",
    "path": "date",
    "invalidValue": "2048-01-01"
  },
  {
    "message": "may not be null",
    "messageTemplate": "{javax.validation.constraints.NotNull.message}",
    "path": "customer",
    "invalidValue": null
  }
]
----


=== Association Attributes

When the entity to create should be linked to another existing entity, it is required to reference the other entity in the request.

In the Order example, you want to reference a Customer via the `customer` attribute when you create the Order. This is done through a JSON object containing only the ID of the existing entity. Jmix performs a lookup of the customer by the provided ID from the JSON request and links the customer to the new order.

[source, http request]
.Request with N:1 reference
----
POST http://localhost:8080/rest/entities/rstex11_Order

{
  "customer": {
    "id": "f88597ff-009d-1cf2-4a90-a4fb5b08d835"
  },
  "date": "2021-03-01",
  "amount": 130.08
}
----

For all kinds of associations: `1:N`, `N:1`, `M:N` the way to reference other entities is the always via its ID.

The second example shows how to link a `Product` to multiple `ProductTag` entities via an `M:N` relationship, as described in the Product entity definition.

[source,java]
.Product.java
----

@JmixEntity
@Table(name = "RSTEX11_PRODUCT")
@Entity(name = "rstex11_Product")
public class Product {

    @JoinTable(name = "RSTEX11_PRODUCT_PRODUCT_TAG_LINK",
            joinColumns = @JoinColumn(name = "PRODUCT_ID"),
            inverseJoinColumns = @JoinColumn(name = "PRODUCT_TAG_ID"))
    @ManyToMany
    private List<ProductTag> tags;

    // ...

}
----

In the request the `ProductTag` entity instances are references by their ids. This time, the JSON object is put into an array, as there are multiple product tags to reference.

[source, http request]
.Request with M:N references
----
POST http://localhost:8080/rest/entities/rstex11_Product?responseFetchPlan=product-with-tags

{
  "name": "123",
  "price": 99.95,
  "tags": [
    {
      "id": "333f3a20-c47b-4bc9-ba34-a72d2d815695" // <1>
    },
    {
      "id": "c4c028f0-fec1-7512-83cd-c17537d1f502"
    }
  ]
}
----

[source, json]
.Response: 201 - Created
----
{
  "_entityName": "rstex11_Product",
  "_instanceName": "123",
  "id": "f0e04748-dcdf-d856-2482-2904f2126fcc",
  "createdDate": "2021-03-02",
  "createdBy": "admin",
  "lastModifiedDate": "2021-03-02",
  "price": 99.95,
  "name": "123",
  "version": 1,
  "tags": [
    {
      "_entityName": "rstex11_ProductTag",
      "_instanceName": "shiny",
      "id": "333f3a20-c47b-4bc9-ba34-a72d2d815695", // <2>
      "name": "shiny"
    },
    {
      "_entityName": "rstex11_ProductTag",
      "_instanceName": "great",
      "id": "c4c028f0-fec1-7512-83cd-c17537d1f502",
      "name": "great"
    }
  ]
}
----
<1> The tags are referenced as a list of JSON objects containing the ID of the already existing `ProductTag`.
<2> The response contains the stored association to the two `ProductTag` entities.

=== Composition Attributes

For attributes that are marked as `@Composition` the situation is slightly different. As this relationship type indicates that the child entities only exists as part of the parent entity, it is also possible to directly create child entites as part of the request to create a parent.

In the next example, the `OrderLine` entity is a child entity of the `Order` entity. This is expressed through the `@Composition` annotation on the `lines` attribute of the `Order` entity.

[source, java]
.Order.java
----
public class Order {
    @JmixGeneratedValue
    @Column(name = "ID", nullable = false)
    @Id
    private UUID id;

    @Composition
    @OneToMany(mappedBy = "order")
    private List<OrderLine> lines;

    // ...
}
----

When you create an order through the API you can directly create its order lines as part of the request. In this case all the attributes of the child entity need to be provided. The relationship from the parent to the child does not need to be additionally referenced. Putting the child entity into the JSON array is enough to establish the connection.

The following JSON request will create an order with its order lines:

[source, http request]
.Request with child entities
----
POST http://localhost:8080/rest/entities/rstex11_Order

{
  "customer": {
    "id": "f88597ff-009d-1cf2-4a90-a4fb5b08d835"
  },
  "date": "2021-03-01",
  "amount": 130.08,
  "lines": [ // <1>
    {
      "quantity": 2,
      "product": {
        "id": "7750adbe-6c30-cede-31a6-577a1a96aa83"  // <2>
      }
    },
    {
      "quantity": 1,
      "product": {
        "code": "1ed85c7a-89f1-c339-a738-16307ed6003a"
      }
    }
  ]
}
----
<1> Order lines are created as an array of JSON objects containing all the attributes of the entity.
<2> In case a child entity needs to reference another entity (like the `N:1` reference from the `OrderLine` to `Product`), the same rules of referencing via JSON object containing the ID apply.


== Update Entities

The Entities API also allows updating already existing entities. The endpoint for this operation is the Update Entity endpoint: `/entities/:entityName/:entityId`. The URL is the same as for the <<Load Entity by ID,Load Entity by ID>> as they are both pointing to the same resource (the entity). But the HTTP method for using the Update Entity endpoint is `PUT`.

When the entity is updated successfully, the HTTP response status code `200 - OK` is returned. By default, a JSON metadata representation of the entity is returned mainly containing the `id` attribute for further reference.

[source, http request]
.Request
----
PUT http://localhost:8080/rest
            /entities
            /rstex11_Customer
            /13f01f59-8e5f-4fd9-802b-66501d49ac99

{
  name: "Updated Name"
}
----


[source, json]
.Response: 200 - OK
----
{
  "_entityName": "rstex11_Customer",
  "_instanceName": "Updated Name",
  "id": "13f01f59-8e5f-4fd9-802b-66501d49ac99"
}
----

Generally the Update Entity API behalves similar to the <<Create Entities,Create Entity API>> regards validation and entity referencing. The differences when it comes to collection Associations will be described below.


=== Association Attributes

In case of an Update of association attributes, the Update Entity endpoint will _replace_ the existing collection, as
