= Entities API

The Entities API provides different capabilities to interact with entity instances. This API mainly consists of CRUD operations that can be performed on the entities. The ability to load entity data is extended by different ways of filtering and JPQL.

NOTE: When performing operations on entities through this generic API, the regular Jmix security permission are applied from the user obtaining the authentication token.


== Load Entities

The Entities API allows different ways to load entities through the API:

* <<Load Entity by ID,Load Entity by ID>> allows to load a single entity by its unique identifier (ID)

* <<Load List of Entities,Load List of Entities>> allows to load all entities without filtering, including pagination.

* <<Load Entities via Search Filter,Load Entities via Search Filter>> allows specifying filters to only load entities that match those criteria

* <<Load Entities via JPQL,Load Entities via JPQL>> allows pre-configuring JPQL queries in the application and use them in the API as named queries


=== Load Entity by ID

The first way of loading an entity via the Entities API is by loading it via its ID. The corresponding endpoint for this is the Load Entity endpoint `entities/:entityName/:entityId`.

The `:entityName` Path parameter defines which entity type it is. The value is defined in the entity definition:

[source,java]
.Order.java
----

@JmixEntity
@Table(name = "RSTEX11_ORDER")
@Entity(name = "rstex11_Order") //<1>
public class Order {
    // ...
}
----
<1> the name attribute value `rstex11_Order` of the `@Entity` JPA annotation indicates the `entityName` parameter in the Entities API

The Load Entity endpoint returns a single instance in case it is found by its identifier. Otherwise, HTTP status code `404 - Not found` is returned.

In the example the Order with the ID `21021f78-edac-224b-e6f8-6e71e02a0f0d` is loaded. Furthermore, in this example the optional URL query parameter `fetchPlan` is used to define which attributes to return as part of the response.

[source, http request]
.Request
----
GET http://localhost:8080/rest
            /entities
            /rstex11_Order
            /21021f78-edac-224b-e6f8-6e71e02a0f0d
            ?fetchPlan=order-with-details
----

[source, json]
.Response: 200 - OK
----
{
  "_entityName": "rstex11_Order", //<1>
  "_instanceName": "rest.sample.entity.Order-21021f78-edac-224b-e6f8-6e71e02a0f0d [detached]",
  "id": "21021f78-edac-224b-e6f8-6e71e02a0f0d",
  "date": "2020-12-13", //<2>
  "amount": 49.99,
  "createdDate": "2021-02-06T12:03:38.049",
  "createdBy": "admin",
  "lastModifiedDate": "2021-02-06T12:03:38.049",
  "lines": [ //<3>
    {
      "_entityName": "rstex11_OrderLine",
      "_instanceName": "rest.sample.entity.OrderLine-64e4fbb0-7fd6-818b-984e-a8769c4fbe88 [detached]",
      "id": "64e4fbb0-7fd6-818b-984e-a8769c4fbe88",
      "product": {
        "_entityName": "rstex11_Product",
        "_instanceName": "Outback Power Remote Power System",
        "id": "7750adbe-6c30-cede-31a6-577a1a96aa83",
        "name": "Outback Power Remote Power System"
      },
      "quantity": 1.0,
      "createdDate": "2021-02-06T12:03:38.049",
      "createdBy": "admin",
      "lastModifiedDate": "2021-02-06T12:03:38.049",
      "version": 1
    }
  ],
  "version": 1,
  "customer": {
    "_entityName": "rstex11_Customer",
    "_instanceName": "Sidney Chandler",
    "id": "0826806e-6074-90fa-f241-564b5c94d018",
    "createdDate": "2021-02-06T12:00:53.72",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:00:53.72",
    "name": "Sidney Chandler",
    "version": 1
  }
}
----
<1> some metadata about the entity instance is returned as JSON keys (`entityName`, `_instanceName` and `id`)
<2> the business attributes of the entity are returned as JSON keys
<3> due to the fetch plan `order-with-details` used in the URL, additional reference attributes are also included like `lines` and `customer`

=== Load List of Entities

The next way of loading entities through the Entities API is to load a list of entities via the Load Entity List API: `/entities/:entityName`. Generally this API allows loading all entity instances of a given type. The API includes pagination, sorting and fetch plans.

[source, http request]
.Request
----
GET http://localhost:8080/rest/entities/rstex11_Customer
----

[source, json]
.Response: HTTP 200 - OK
----
[
  {
    "_entityName": "rstex11_Customer",
    "_instanceName": "Sidney Chandler",
    "id": "0826806e-6074-90fa-f241-564b5c94d018",
    "createdDate": "2021-02-06T12:00:53.72",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:00:53.72",
    "name": "Sidney Chandler",
    "version": 1
  },
  {
    "_entityName": "rstex11_Customer",
    "_instanceName": "Randall Bishop",
    "id": "22efc597-69a9-aeef-4e4a-7afccd8e5767",
    "createdDate": "2021-03-01T08:19:08.871",
    "createdBy": "admin",
    "lastModifiedDate": "2021-03-01T08:19:08.871",
    "name": "Randall Bishop",
    "version": 1
  },
  {
    "_entityName": "rstex11_Customer",
    "_instanceName": "Shelby Robinson",
    "id": "bd1c8e90-3d35-cbe2-9efd-167202c758d2",
    "createdDate": "2021-02-06T12:02:05.328",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:02:05.328",
    "name": "Shelby Robinson",
    "version": 1
  }
]
----

It is also possible to further control the behavior of the API by using the following URL query parameter.

[NOTE]
.Load Entity List API Query Parameters
====
[horizontal]
fetchPlan:: name of an entity types xref:data-access:fetch-plans.adoc[fetch plan], that will determine the JSON attributes each entity contains `(String)`
limit:: the number of entities to be returned by the API `(int)`
offset:: the position of the first returned entity `(int)`
sort:: an entity attribute that will be used for sorting. `+attribute` or `attribute` for ascending order, `-attribute` for descending order `(String)`
====

In the following example the third "page" of 5 `Order` entities should be loaded (the 10 - 15 entity) sorted by the `date` attribute containing all attributes of the `order-with-details` fetch plan.

[source, http request]
.Request
----
GET http://localhost:8080/rest
            /entities
            /rstex11_Order
            ?fetchPlan=order-with-details
            &limit=5
            &offset=10
            &sort=+date
----

[source, json]
.Response: HTTP 200 - OK
----
[
  {
    "_entityName": "rstex11_Order",
    "_instanceName": "rest.sample.entity.Order-21021f78-edac-224b-e6f8-6e71e02a0f0d [detached]",
    "id": "21021f78-edac-224b-e6f8-6e71e02a0f0d",
    "date": "2020-12-13",
    "amount": 49.99,
    "createdDate": "2021-02-06T12:03:38.049",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:03:38.049",
    "lines": [
      {
        "_entityName": "rstex11_OrderLine",
        "_instanceName": "rest.sample.entity.OrderLine-64e4fbb0-7fd6-818b-984e-a8769c4fbe88 [detached]",
        "id": "64e4fbb0-7fd6-818b-984e-a8769c4fbe88",
        "product": {
          "_entityName": "rstex11_Product",
          "_instanceName": "Outback Power Remote Power System",
          "id": "7750adbe-6c30-cede-31a6-577a1a96aa83",
          "name": "Outback Power Remote Power System"
        },
        "quantity": 1.0,
        "createdDate": "2021-02-06T12:03:38.049",
        "createdBy": "admin",
        "lastModifiedDate": "2021-02-06T12:03:38.049",
        "version": 1
      }
    ],
    "version": 1,
    "customer": {
      "_entityName": "rstex11_Customer",
      "_instanceName": "Sidney Chandler",
      "id": "0826806e-6074-90fa-f241-564b5c94d018",
      "createdDate": "2021-02-06T12:00:53.72",
      "createdBy": "admin",
      "lastModifiedDate": "2021-02-06T12:00:53.72",
      "name": "Sidney Chandler",
      "version": 1
    }
  },
  {
    "_entityName": "rstex11_Order",
    "_instanceName": "rest.sample.entity.Order-41aae331-b46b-85ee-b0bc-2de8cbf1ab86 [detached]",
    "id": "41aae331-b46b-85ee-b0bc-2de8cbf1ab86",
    "date": "2021-02-02",
    "amount": 283.55,
    "createdDate": "2021-02-06T12:04:37.372",
    "createdBy": "admin",
    "lastModifiedDate": "2021-02-06T12:04:37.372",
    "lines": [
      {
        "_entityName": "rstex11_OrderLine",
        "_instanceName": "rest.sample.entity.OrderLine-d89df652-9d06-8d3e-2f26-5387e96e5b5d [detached]",
        "id": "d89df652-9d06-8d3e-2f26-5387e96e5b5d",
        "product": {
          "_entityName": "rstex11_Product",
          "_instanceName": "Cotek Battery Charger",
          "id": "1ed85c7a-89f1-c339-a738-16307ed6003a",
          "name": "Cotek Battery Charger"
        },
        "quantity": 1.0,
        "createdDate": "2021-02-06T12:04:37.372",
        "createdBy": "admin",
        "lastModifiedDate": "2021-02-06T12:04:37.372",
        "version": 1
      },
      {
        "_entityName": "rstex11_OrderLine",
        "_instanceName": "rest.sample.entity.OrderLine-7ccd45ec-8878-2a4a-2c24-b5ac053b6d4c [detached]",
        "id": "7ccd45ec-8878-2a4a-2c24-b5ac053b6d4c",
        "product": {
          "_entityName": "rstex11_Product",
          "_instanceName": "Solar-One HUP Flooded Battery 48V",
          "id": "1860904a-5444-9c3e-9dc1-1d7a26d9ac19",
          "name": "Solar-One HUP Flooded Battery 48V"
        },
        "quantity": 1.0,
        "createdDate": "2021-02-06T12:04:37.372",
        "createdBy": "admin",
        "lastModifiedDate": "2021-02-06T12:04:37.372",
        "version": 1
      }
    ],
    "version": 1,
    "customer": {
      "_entityName": "rstex11_Customer",
      "_instanceName": "Shelby Robinson",
      "id": "bd1c8e90-3d35-cbe2-9efd-167202c758d2",
      "name": "Shelby Robinson",
      "version": 1
    }
  }
]
----

NOTE: Every entity in the response has a `_entityName` attribute with the name of the entity, and an `_instanceName` attribute with the xref:data-model:entities.adoc#instance-name[Instance Name] of the entity.

=== Load Entities via Search Filter

It is possible to specify filter criteria when fetching entities. For this use-case the Entity Search Endpoint is available via `/entities/:entityName/search`.

Both HTTP methods `GET` and `POST` are possible when interacting with the search endpoint. In both cases the filter criterion has to be provided as part of the request.

The filter definition is a JSON structure that contains a set of conditions. A condition contains of the attributes' `property`, `operator` and `value`.

[NOTE]
.Filter Condition
====
[horizontal]
property:: the entity attribute that is being filtered on (like `amount` on the Order entity).
+
In case the attribute is a reference to another entity, it can also be a property path like `customer.name`

operator:: the filter operator. The following values are possible (depending on the property type):
+
`=`, `>`, `>=`, `<`, `&lt;=`, `<>`, `startsWith`, `endsWith`, `contains`, `doesNotContain`, `in`, `notIn`, `notEmpty`, `isNull`

value:: the value to search for. Value is required expect for the operators `notEmpty` and `isNull`
====

Additionally, conditions can be combined via `AND`, `OR` group conditions in order to define more complex filter criterion. The JSON structure of the filter definitions looks like this:

[source,json]
.Filter Criterion JSON structure
----
{
  "conditions": [
    {
      "group": "OR",
      "conditions": [
        {
          "property": "stringField",
          "operator": "=",
          "value": "stringValue"
        },
        {
          "property": "intField",
          "operator": ">",
          "value": 100
        }
      ]
    },
    {
      "property": "booleanField",
      "operator": "=",
      "value": true
    }
  ]
}
----

This is a representation of the Filter criterion: `((stringField = stringValue) OR (intField > 100) AND (booleanField = true))`.

When using the HTTP POST method, the filter is part of the request body.

[source,http request]
.Filter POST Request
----
POST http://localhost:8080/rest/entities/rstex11_Order/search

{
  "filter": {
    "conditions": [
      {
        "property": "customer.name",
        "operator": "=",
        "value": "Shelby Robinson"
      }
    ]
  }
}
----

When using the `GET` method, the JSON filter criterion needs to be transferred via the URL Query parameter `filter`.

[source, http request]
.Filter GET Request
----
GET http://localhost:8080/rest
            /entities
            /rstex11_Order
            /search
            ?filter={"conditions":[{"property":"customer.name","operator":"contains","value":"Shelby"}]}
----

[IMPORTANT]
.URI Encoding
====
The HTTP URI standard only allows ASCII characters as part of the URI / URL. When using URL Query parameters for the filter definition, the JSON definition has to be URL encoded in order to match this requirement. This is also true for the `value` data that normally contains user-input.

As there is also a practical limit of the URI length that can cause problems for big filter definitions, the `POST` method for filtering entities should be preferred as those restrictions do not apply.
====

=== Load Entities via JPQL

Another alternative to load entities from the application is to use predefined JPQL queries. The Entity Query Endpoint `/queries/:entityName/:queryName` is responsible for providing this capability. Queries can contain a list of parameters, that needs to be provided by the client. Additionally, the endpoint contains the same general parameters for pagination, fetchPlans etc.


[TIP]
.When to use JPQL vs. Search Filter?
====
Jmix provides various ways to load entity data in a generic way. Using pre-defined JPQL queries can be used when the search filter are not advanced enough to express the filter criterion. Also in case the parameter should be pre-defined and not be adjustable by the API client.
====

==== JPQL Query Configuration

In order to use the Entity Query endpoint, the accessible queries need to be defined and exposed within the application. Queries are configured via a XML configuration file (normally called `rest-queries.xml`). This file needs to be registered as a query configuration in your application properties file:

[source,properties]
.application.properties
----
jmix.rest.queriesConfig = rest/sample/rest-queries.xml
----

The `rest-queries.xml` configuration needs to be created in your Jmix application under `src/main/resources`. It lists all published queries with information about its parameters.

[source,xml]
.rest-queries.xml
----
<?xml version="1.0"?>
<queries xmlns="http://jmix.io/schema/rest/queries">
    <query name="ordersByDate" entity="rstex11_Order" fetchPlan="order-with-details">
        <jpql><![CDATA[select e from rstex11_Order e where e.date = :orderDate]]></jpql>
        <params>
            <param name="orderDate" type="java.time.LocalDate"/>
        </params>
    </query>
    <query name="ordersByCustomerName" entity="rstex11_Order" fetchPlan="order-with-details">
        <jpql><![CDATA[select e from rstex11_Order e where e.customer.name = :customerName]]></jpql>
        <params>
            <param name="customerName" type="java.lang.String"/>
        </params>
    </query>
</queries>
----

A query needs to have a unique `name` value as well as an `entity` reference. The combination of `name` and `entity` needs to be unique. Also, a `fetchPlan` needs to be referenced to indicate which entity attributes are returned.

In the `<jpql>` tag the actual query is configured. Parameters are referenced via their name prefixed with a colon like `:customerName`.
The parameters itself need to be listed within the `params` tag defining their name and Java type.

The Entity Query endpoint can be invoked by the `GET` or `POST` HTTP method. In case of the `GET`, the parameters are appended
as URL query parameters.

[source, http request]
.Query API GET Request
----
GET http://localhost:8080/rest
        /queries
        /rstex11_Order
        /ordersByDate
        ?orderDate=2020-02-02
----


[IMPORTANT]
.URI Encoding
====
Similar to the Entity Search Endpoint the URL should only contain ASCII characters. This means the values of the parameters need to be URL encoded, as those values normally represent direct user input and therefore it cannot be ensured that non-ascii characters are used.
====

In the case of using `POST`, the query parameters are transferred in the JSON body containing each parameter as a key.

[source, http request]
.Query API POST Request
----
POST http://localhost:8080/rest/queries/rstex11_Order/ordersByCustomerName

{
  "customerName": "Shelby Robinson"
}
----

==== Collection Parameters

It is also possible to define a parameter as a collection type. In this case the query definition should contain a `[]` indicator after the Java type.

[source,xml]
.rest-queries.xml
----
<?xml version="1.0"?>
<queries xmlns="http://jmix.io/schema/rest/queries">
    <query name="ordersByIds" entity="rstex11_Order" fetchPlan="order-with-details">
        <jpql><![CDATA[select e from rstex11_Order e where e.id in :ids]]></jpql>
        <params>
            <param name="ids" type="java.util.UUID[]"/> // <1>
        </params>
    </query>
</queries>
----
<1> the `ids` parameter is marked as collection of `UUID` type

When this parameter is used in a query, the corresponding  IDs have to be provided as a JSON array.

[source, http request]
.Query API Collection Parameters Request
----
POST http://localhost:8080/rest/queries/rstex11_Order/ordersByIds

{
  "ids": [
    "41aae331-b46b-85ee-b0bc-2de8cbf1ab86",
    "21021f78-edac-224b-e6f8-6e71e02a0f0d"
  ]
}
----

== Create Entities

The Entities API allows creating entities through the Create Entity endpoint. An entity can be created via performing a `POST` request against the endpoint: `/entities/:entityName`.

The request body contains a JSON object with the attributes of the entity.

NOTE: Attributes from xref:data-model:entities.adoc#traits[entity traits] like `id` or `createdBy` should not be part of the request. Those attributes are automatically added by Jmix while storing the entity.

When the entity is created successfully, the HTTP response status code `201 - Created` is returned. By default, a JSON metadata representation of the entity is returned mainly containing the newly created `id` attribute for further reference.

[source, http request]
.Request
----
POST http://localhost:8080/rest/entities/rstex11_Customer

{
  name: "Randall Bishop"
}
----


[source, json]
.Response: 201 - Created
----
{
  "_entityName": "rstex11_Customer",
  "_instanceName": "Randall Bishop",
  "id": "78e7996d-8b69-6526-8e9f-16262a1c4113"
}
----

Alternatively it is possible to define which attributes should be returned once the entity is created. This can be achieved through the URL query parameter `responseFetchPlan`. E.g. `/entities/rstex11_Order?responseFetchPlan=order-with-details` would return the complete order with all its details containing order lines, customer references etc.

TIP: The HTTP response Header `Location` indicates also the URL to the newly created entity instance for further operations (like fetching, updating or deleting).

=== Entity Validation

When an entity is created or updated by default the regular entity validation is active and enforced. This means that invalid input (according to the entity validation annotations) from the API is rejected with the HTTP response status code `400 - Bad Request`.

The API returns detailed error messages for each validation violation in the following form of an JSON array. Each entry follows the structre

[NOTE]
.Validation Error structure
====
[horizontal]
message:: the (translated) human-readable error message of the violation
messageTemplate:: the non-interpolated error message for this constraint violation
path:: the attribute name (or property path) of the attribute that caused the violation
invalidValue:: the value that was part of the request for the attribute, which causes the violation
====

The following request contains two errors in the request, as 1. the `customer` attribute is required and 2. the `date` should not be in the future.

[source, http request]
.Invalid Request
----
POST http://localhost:8080/rest/entities/rstex11_Order

{
  "date": "2048-01-01",
  "amount": 49.99,
  "customer": null
}
----

The API then returns the list of violations of the entity validations.

[source, json]
.Response: 400 - Bad Request
----
[
  {
    "message": "javax.validation.constraints.PastOrPresent.message",
    "messageTemplate": "{javax.validation.constraints.PastOrPresent.message}",
    "path": "date",
    "invalidValue": "2048-01-01"
  },
  {
    "message": "may not be null",
    "messageTemplate": "{javax.validation.constraints.NotNull.message}",
    "path": "customer",
    "invalidValue": null
  }
]
----


=== Association Attributes

When the entity to create should be linked to another, already existing entity it is required to reference the other entity in the request. In the Order example, a `customer` needs to be referenced when an Order is created. This is done through a JSON object containing only the ID of the existing entity. Jmix performs a lookup of the customer by the provided ID from the JSON request and links the customer to the new order.

[source, http request]
.Request with N:1 reference
----
POST http://localhost:8080/rest/entities/rstex11_Order

{
  "customer": {
    "id": "f88597ff-009d-1cf2-4a90-a4fb5b08d835"
  },
  "date": "2021-03-01",
  "amount": 130.08
}
----

For all kinds of associations: `1:N`, `N:1`, `M:N` the way to reference other entities is the always via its ID.

The second example shows how to link a `Product` to multiple `ProductTag` entities via an `M:N` relationship, as described in the Product entity definition.

[source,java]
.Product.java
----

@JmixEntity
@Table(name = "RSTEX11_PRODUCT")
@Entity(name = "rstex11_Product")
public class Product {

    @JoinTable(name = "RSTEX11_PRODUCT_PRODUCT_TAG_LINK",
            joinColumns = @JoinColumn(name = "PRODUCT_ID"),
            inverseJoinColumns = @JoinColumn(name = "PRODUCT_TAG_ID"))
    @ManyToMany
    private List<ProductTag> tags;

    // ...

}
----

In the request the `ProductTag` entity instances are references by their ids. This time, the JSON object is put into an array, as there are multiple product tags to reference.

[source, http request]
.Request with M:N references
----
POST http://localhost:8080/rest/entities/rstex11_Product?responseFetchPlan=product-with-tags

{
  "name": "123",
  "price": 99.95,
  "tags": [
    {
      "id": "333f3a20-c47b-4bc9-ba34-a72d2d815695" // <1>
    },
    {
      "id": "c4c028f0-fec1-7512-83cd-c17537d1f502"
    }
  ]
}
----

[source, json]
.Response: 201 - Created
----
{
  "_entityName": "rstex11_Product",
  "_instanceName": "123",
  "id": "f0e04748-dcdf-d856-2482-2904f2126fcc",
  "createdDate": "2021-03-02",
  "createdBy": "admin",
  "lastModifiedDate": "2021-03-02",
  "price": 99.95,
  "name": "123",
  "version": 1,
  "tags": [
    {
      "_entityName": "rstex11_ProductTag",
      "_instanceName": "shiny",
      "id": "333f3a20-c47b-4bc9-ba34-a72d2d815695", // <2>
      "name": "shiny"
    },
    {
      "_entityName": "rstex11_ProductTag",
      "_instanceName": "great",
      "id": "c4c028f0-fec1-7512-83cd-c17537d1f502",
      "name": "great"
    }
  ]
}
----
<1> the tags are referenced as a list of JSON objects containing the ID of the already existing `ProductTag`
<2> the response contains the stored association to the two `ProductTag` entities

=== Composition Attributes

For attributes that are marked as `@Composition` the situation is slightly different. As this relationship type indicates that the child entities only exists as part of the parent entity, it is also possible to directly create child entites as part of the request to create a parent.

In the next example, the `OrderLine` entity is a child entity of the `Order` entity. This is expressed through the `@Composition` annotation on the `lines` attribute of the `Order` entity.

[source, java]
.Order.java
----
public class Order {
    @JmixGeneratedValue
    @Column(name = "ID", nullable = false)
    @Id
    private UUID id;

    @Composition
    @OneToMany(mappedBy = "order")
    private List<OrderLine> lines;

    // ...
}
----

When an order is created through the API it is possible to directly create its order lines as part of the request. In this case all the attributes of the child entity need to be provided, in order to create it. The relationship from the parent to the child does not need to be additionally referenced. Putting the child entity into the JSON array is enough to establish the connection.

The following JSON request will create an order with its order lines:

[source, http request]
.Request with child entities
----
POST http://localhost:8080/rest/entities/rstex11_Order

{
  "customer": {
    "id": "f88597ff-009d-1cf2-4a90-a4fb5b08d835"
  },
  "date": "2021-03-01",
  "amount": 130.08,
  "lines": [ // <1>
    {
      "quantity": 2,
      "product": {
        "id": "7750adbe-6c30-cede-31a6-577a1a96aa83"  // <2>
      }
    },
    {
      "quantity": 1,
      "product": {
        "code": "1ed85c7a-89f1-c339-a738-16307ed6003a"
      }
    }
  ]
}
----
<1> order lines are created as an array of JSON objects containing all the attributes of the entity
<2> in case a child entity needs to reference another entity (like the `N:1` reference from the `OrderLine` to `Product`), the same rules of referencing via JSON object containing the ID apply


== Update Entities
